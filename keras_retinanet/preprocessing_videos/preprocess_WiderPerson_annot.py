# -*- coding: utf-8 -*-
"""evaluation_retinanet_models.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ltKO6FzL3ZKrlpw9aPUNFR8wlJEgcRcV
"""
# Commented out IPython magic to ensure Python compatibility.
import os
import numpy as np
import tensorflow as tf
import pandas as pd
import seaborn as sns
from pylab import rcParams
import matplotlib.pyplot as plt
from matplotlib import rc
from pandas.plotting import register_matplotlib_converters
from sklearn.model_selection import train_test_split
import urllib
import csv
import cv2
import time
from PIL import Image
from IPython.core.debugger import set_trace
import shutil
import time
import pdb

from keras_retinanet import models
from keras_retinanet.utils.image import read_image_bgr, preprocess_image, resize_image
from keras_retinanet.utils.visualization import draw_box, draw_caption
from keras_retinanet.utils.colors import label_color
from keras_retinanet.bin import evaluate

#remove other classes than pedestrian and make partially visible to pedestrian
def filter_classes(df):
  df_filtered= df.loc[(df.label == 'pedestrian') | (df.label == 'partially-visible')]
  df_filtered.replace(to_replace='partially-visible', value='pedestrian', inplace=True)
  print('reduced from ', df.shape, 'to', df_filtered.shape)
  return df_filtered


#Check for wrongly annotaded bounding boxes
def check_bb(path):
  colnames = ['filename', 'x1', 'y1', 'x2', 'y2', 'class_label']
  df = pd.read_csv(path, names=colnames)
  df_new = df.loc[(df.x1 < df.x2) & (df.y1 < df.y2), : ]
  print ('Reduces shape from ', df.shape, 'to ', df_new.shape)
  return df_new


def generate_annotations():
  # Generate the classes csv file
  annot = os.listdir(annot_path)
  with open(keras_path + '/annotations.csv', newline='', mode='x') as csvfile:
    csv_writer = csv.writer(csvfile, delimiter=',')
    for filename in os.listdir(images_path_sample)[0:10]:
      if str(filename + '.txt') in annot:
        f = open(annot_path + '/' +  filename + '.txt', 'r')
        
        for index, line in enumerate(f): 
          if index == 0: 
            if line.strip() == '0':
              print('Not any  object in the image!')
            continue
            
          else: 
            split_line = line[:line.find('/')].split(' ')
            first_char = split_line.pop(0)
            split_line.insert(len(split_line), first_char)
            split_line.insert(0, images_path + '/' + filename)
            #convert from index to class label 
            try:
              split_line[-1] = classes_ids[int(split_line[-1])]
            except: 
              continue
            split_line[0] = split_line[0]

            csv_writer.writerow(split_line)
        
        f.close()
  return


def replace_annoation_folder(new_path, csv_annot_path, img_path):
  '''Start this function from folder root, otherwise wont work properly'''

  df_annot = pd.read_csv('/content/annotations_sample.csv',
                         names=['name', 'x1', 'y1', 'x2', 'y2', 'label'])
  df_annot = df_annot.reset_index().drop(0).drop(columns='index')
  df_annot['name'] = df_annot['name'].str.replace(img_path, new_path)
  df_annot = df_annot.dropna()
  df_annot.to_csv(csv_annot_path + '/annotations_sampledata.csv',
                  index=None, header=None)
  return

def predict(image):
  image = preprocess_image(image.copy())
  image, scale = resize_image(image)

  boxes, scores, labels = model.predict_on_batch(
    np.expand_dims(image, axis=0)
  )

  boxes /= scale

  return boxes, scores, labels

def filter_images_by_size(df, max_size=4000, min_size=440):
  start_size = len(os.listdir(images_path_sample))
  for image_name in os.listdir(images_path_sample):
    try: 
      image = read_image_bgr(images_path_sample + '/' + image_name)
      if (min(image.shape[0:2]) < min_size) or (max(image.shape[0:2]) > max_size):
        df = df[~df.image_name.str.contains(image_name)]
    except: 
      print('Image not in dataset. Name of file: ', image_name)
  print('final df shape: ', df.shape)
  print('Removed ',start_size - df.image_name.nunique() , 'images')
  return df

def show_image_objects(image_rows):
  image = read_image_bgr(image_rows.iloc[0].image_name)
  draw = image.copy()

  for image_row in image_rows.itertuples():
    box = [image_row.x_min, image_row.y_min, image_row.x_max, image_row.y_max]
    draw_box(draw, box, color=(255, 255, 0))
  draw = cv2.cvtColor(draw, cv2.COLOR_BGR2RGB)

  plt.axis('off')
  plt.imshow(draw)
  plt.show()

